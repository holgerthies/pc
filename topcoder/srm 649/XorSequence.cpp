#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <limits>
#include <tuple>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#define REP(k,a) for(int k=0; k < (a); ++k)
#define INF 200000000
#define mp make_pair
#define len(s) (int)((s).size())
#define pb push_back
using namespace std;
typedef long long ll;
typedef unsigned int uint;
using vi = vector<int>;
using vii = vector<vector<int>>;
using pii = pair<int,int>;


ll mergeCount(vi& A, int left, int middle, int right){
	vi srt(right-left+1);
	int i=left, j=middle+1;
	int c=0;
	ll ans=0;
	while(i <= middle && j<=right){
		if(A[i] <= A[j]){
			srt[c] = A[i];
			i++;
		} else{
			srt[c] = A[j];
			j++;
			ans += (ll)(middle-i+1);
		}
		c++;
	}
	while(i <= middle){
		srt[c] = A[i];
		i++;
		c++;
	}
	while(j <= right){
		srt[c] = A[j];
		j++;
		c++;
	}
	REP(k, right-left+1){
		A[k+left] = srt[k];
	}
	return ans;
}

ll count(vi& A, int left, int right){
	if(right <= left)
		return 0;
	int middle = (left+right)/2;
	ll ans=count(A, left, middle)+count(A, middle+1, right);
	ans += mergeCount(A, left, middle, right);
	return ans;
}

class XorSequence {
public:
	long long getmax(int N, int sz, int A0, int A1, int P, int Q, int R) {
		vi A(sz);
		A[0] = A0;
		A[1] = A1;
		for (int i = 2; i < sz; i++) {
		    A[i] = ((ll)A[i - 2] * P + (ll)A[i - 1] * Q + (ll)R) % N;
		}
		int max_digit = log2(N);
		if((1 << max_digit) != N){
			max_digit--;
			if((1 << max_digit) != N) max_digit += 2;
		}
		REP(i, max_digit+1){
			int d = 1 << (max_digit-i);
			vi A1(A);
			vi A2(A);
			REP(j, len(A1)) A2[j] ^= d;
			vi A3(A2);
			if(count(A2, 0, len(A2)-1) > count(A1, 0, len(A1)-1))
				A = A3;
		}

		ll c = count(A,0, len(A)-1);
		
		return c;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit-pf 2.3.0
#include <iostream>
#include <string>
#include <vector>
#include <ctime>
#include <cmath>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, int p3, int p4, int p5, int p6, bool hasAnswer, long long p7) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2 << "," << p3 << "," << p4 << "," << p5 << "," << p6;
	cout << "]" << endl;
	XorSequence *obj;
	long long answer;
	obj = new XorSequence();
	clock_t startTime = clock();
	answer = obj->getmax(p0, p1, p2, p3, p4, p5, p6);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p7 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p7;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	bool disabled;
	bool tests_disabled;
	all_right = true;
	tests_disabled = false;
	
	int p0;
	int p1;
	int p2;
	int p3;
	int p4;
	int p5;
	int p6;
	long long p7;
	
	// ----- test 0 -----
	disabled = false;
	p0 = 4;
	p1 = 6;
	p2 = 3;
	p3 = 2;
	p4 = 0;
	p5 = 1;
	p6 = 3;
	p7 = 8ll;
	all_right = (disabled || KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, p5, p6, true, p7) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 1 -----
	disabled = false;
	p0 = 8;
	p1 = 8;
	p2 = 2;
	p3 = 5;
	p4 = 3;
	p5 = 1;
	p6 = 4;
	p7 = 13ll;
	all_right = (disabled || KawigiEdit_RunTest(1, p0, p1, p2, p3, p4, p5, p6, true, p7) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 2 -----
	disabled = false;
	p0 = 8;
	p1 = 7;
	p2 = 3;
	p3 = 0;
	p4 = 1;
	p5 = 2;
	p6 = 4;
	p7 = 12ll;
	all_right = (disabled || KawigiEdit_RunTest(2, p0, p1, p2, p3, p4, p5, p6, true, p7) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 3 -----
	disabled = false;
	p0 = 32;
	p1 = 15;
	p2 = 7;
	p3 = 9;
	p4 = 11;
	p5 = 2;
	p6 = 1;
	p7 = 60ll;
	all_right = (disabled || KawigiEdit_RunTest(3, p0, p1, p2, p3, p4, p5, p6, true, p7) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 4 -----
	disabled = false;
	p0 = 131072;
	p1 = 131072;
	p2 = 7;
	p3 = 7;
	p4 = 1;
	p5 = 0;
	p6 = 0;
	p7 = 0ll;
	all_right = (disabled || KawigiEdit_RunTest(4, p0, p1, p2, p3, p4, p5, p6, true, p7) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	// ----- test 5 -----
	disabled = false;
	p0 = 65536;
	p1 = 18504;
	p2 = 14443;
	p3 = 22184;
	p4 = 30654;
	p5 = 7132;
	p6 = 41092;
	p7 = 536018ll;
	all_right = (disabled || KawigiEdit_RunTest(5, p0, p1, p2, p3, p4, p5, p6, true, p7) ) && all_right;
	tests_disabled = tests_disabled || disabled;
	// ------------------
	
	if (all_right) {
		if (tests_disabled) {
			cout << "You're a stud (but some test cases were disabled)!" << endl;
		} else {
			cout << "You're a stud (at least on given cases)!" << endl;
		}
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// You are given an integer sequence A and an int N that is a power of 2.
// All elements of A are between 0 and N-1, inclusive.
// 
// You can now choose an integer B which is between 0 and N-1, inclusive.
// This integer determines a new sequence C defined as follows:
// For each valid i, C[i] = (A[i] xor B).
// 
// Given the sequence C, we will count the pairs of indices (i,j) such that both i<j and C[i]<C[j].
// Compute and return the largest result we can obtain.
// 
// You are given the int N.
// You are also given ints sz, A0, A1, P, Q, and R.
// Use the following pseudocode to generate the sequence A:
// 
// 
// A[0] = A0;
// A[1] = A1;
// for (i = 2; i < sz; i++) {
//     A[i] = (A[i - 2] * P + A[i - 1] * Q + R) modulo N;
// }
// 
// 
// DEFINITION
// Class:XorSequence
// Method:getmax
// Parameters:int, int, int, int, int, int, int
// Returns:long long
// Method signature:long long getmax(int N, int sz, int A0, int A1, int P, int Q, int R)
// 
// 
// NOTES
// -Watch out for integer overflow when generating the sequence A.
// 
// 
// CONSTRAINTS
// -N will be between 2 and 1,073,741,824 (2^30), inclusive.
// -N will be a power of 2. 
// -sz will be between 2 and 131,072, inclusive.
// -A0 will be between 0 and N-1, inclusive.
// -A1 will be between 0 and N-1, inclusive.
// -P will be between 0 and N-1, inclusive.
// -Q will be between 0 and N-1, inclusive.
// -R will be between 0 and N-1, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// 4
// 6
// 3
// 2
// 0
// 1
// 3
// 
// Returns: 8
// 
// Using the provided pseudocode you should compute that A={3,2,1,0,3,2}.
// For B=3 we then get C={0,1,2,3,0,1}.
// For this C there are 8 pairs (i,j) such that i<j and C[i]<C[j].
// These are the 8 pairs: (0,1), (0,2), (0,3), (0,5), (1,2), (1,3), (2,3), and (4,5).
// No other choice of B produces more than 8 pairs.
// 
// 1)
// 8
// 8
// 2
// 5
// 3
// 1
// 4
// 
// Returns: 13
// 
// A={2,5,7,2,3,5,2,5}.
// 
// 2)
// 8
// 7
// 3
// 0
// 1
// 2
// 4
// 
// Returns: 12
// 
// A={3,0,7,2,7,4,3}.
// 
// 3)
// 32
// 15
// 7
// 9
// 11
// 2
// 1
// 
// Returns: 60
// 
// A={7,9,0,4,9,31,2,26,11,21,4,16,13,11,6}.
// 
// 4)
// 131072
// 131072
// 7
// 7
// 1
// 0
// 0
// 
// Returns: 0
// 
// All elements of A are equal to 7.
// Regardless of the value of B you choose, all elements in C will be equal as well.
// Thus, the number of pairs we seek is always zero.
// 
// 5)
// 131072
// 131070
// 411
// 415
// 398
// 463
// 9191
// 
// Returns: 4302679760
// 
// 
// 
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit-pf 2.3.0!
